"""
MLB Real-Time Prediction & Betting Orchestrator v6
---------------------------------------------------
This script serves as the final production endpoint for generating daily MLB
predictions and betting decisions. It orchestrates the components from the
entire MLOps pipeline:

1.  **Feature Generation**: Uses the `MLBDailyPipeline` from `testingInference.py`
    to generate features for the target date, loading the exact historical feature
    states created by `sqlMLBqueryv5.py` to ensure train/serve consistency.

2.  **Model Loading**: Loads all artifacts (neural networks, stacking ensembles,
    scalers, feature selectors) created by the `pipelineTrainv5.py` training script.

3.  **Prediction Ensemble**: Reconstructs the full base model and stacking ensemble
    to generate the final, most accurate predictions for game scores and outcomes.

4.  **Betting Decision**: Translates predictions and live market odds into quantifiable
    betting opportunities, which are then fed to the trained Reinforcement Learning
    agent from `bettingModelv5.py` for final, optimized betting decisions.
"""

import pandas as pd
import numpy as np
from datetime import datetime
import logging
import os
import joblib
import json
import torch
import warnings
from typing import Dict, List, Any, Tuple# --- Import Core Components from Project Scripts ---
from collections import defaultdict
from tqdm import tqdm
import gspread
from gspread_dataframe import set_with_dataframe
import subprocess
# --- Import Core Components from Project Scripts ---
# Feature generation pipeline that uses saved historical states
from testingInference import MLBDailyPipeline
import pytz # Add pytz for timezone conversion

# Model architectures, loss functions, and the stacking ensemble
from pipelineTrainv5 import (
    ImprovedFeatureSelector, # <--- ADD THIS LINE
    MLBNeuralNetV2,
    MLBNeuralNetV3,
    MLBHybridModel,
    MLBNeuralNetWithUncertainty,
    ModelConfig,
    StackingEnsemble,
    AdvancedFeatureEngineer,
    MLBGraphNeuralNetwork,
    TeamGraphAttention,
    TemporalTeamEncoder,
    PerceiverBlock,
    BaseModelWrapper
)
import pipelineTrainv5
from bettingModelv4 import AdvancedCallbacks, EnhancedDataPreprocessor, PortfolioAnalyzer

from sqlMLBqueryv5 import DatabaseConnection, FeatureEngineer, PipelineConfig

# Reinforcement learning environment and betting opportunity dataclass
from bettingModelv5 import (
    BettingOpportunity,
    MLBBettingEnvironmentV4
)

# Stable Baselines for loading the trained RL agent
try:
    from stable_baselines3 import PPO
except ImportError:
    PPO = None
    logging.warning("stable_baselines3 not found. RL agent functionality will be disabled.")

# In mlb_realtimeBet.py, add this with your other imports

from bettingModelv3 import ImprovedProbabilityCalculator, ImprovedConfidenceCalculator, DynamicKellyCalculator, MLBBettingModelV2, BettingConfig, EnhancedBet, EnhancedProbabilityCalibrator
warnings.filterwarnings('ignore')
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Define the paths to the model artifacts generated by pipelineTrainv5.py
MODEL_ARTIFACTS_DIR = "./mlb_run_prediction_model_v4"
RL_AGENT_PATH = "trained_betting_agent_v4_final"


class RealtimePredictionOrchestrator:
    """
    Orchestrates the end-to-end process of generating daily MLB predictions
    and betting decisions.
    """
    # In mlb_realtimeBet.py -> RealtimePredictionOrchestrator class
    # In RealtimePredictionOrchestrator class
    def __init__(self, rl_agent_path: str):
        self.rl_agent_path = rl_agent_path
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        logger.info(f"Using device: {self.device}")

        # --- REFACTOR: Initialize the V3 model to handle all analysis ---
        self.config = BettingConfig()
        self.model = MLBBettingModelV2(self.config)
        
        self._load_rl_agent()
        
        # The feature pipeline for live data remains the same
        self.feature_pipeline = MLBDailyPipeline()
        
        try:
            logger.info("Connecting to SQL database...")
            db_config = PipelineConfig()
            self.db_connection = DatabaseConnection(db_config)
            if not self.db_connection.connect():
                raise ConnectionError("Failed to connect to the database.")
            self._load_team_mappings()
            logger.info("✅ Database connection and team mappings loaded.")
        except Exception as e:
            logger.error(f"❌ Could not establish database connection or load mappings: {e}")

    # In mlb_realtimeBet.py

    def _load_team_mappings(self):
        """Loads both team name and team ID mappings from the database."""
        query = "SELECT full_name, abbrev, team_id FROM team_abbrev_map"
        df = pd.read_sql(query, self.db_connection.engine)
        
        # Drop duplicates to ensure a clean map
        df_unique_names = df.drop_duplicates(subset=['full_name'], keep='first')
        self.full_name_to_abbrev = dict(zip(df_unique_names['full_name'], df_unique_names['abbrev']))
        
        df_unique_ids = df.drop_duplicates(subset=['team_id'], keep='first')
        self.team_id_to_abbrev = dict(zip(df_unique_ids['team_id'], df_unique_ids['abbrev']))

    def _normalize_team_name(self, team_name):
        """Converts API team name to standard abbreviation using SQL mapping."""
        return self.full_name_to_abbrev.get(team_name, team_name)

    def _decimal_to_american(self, decimal_odds: float) -> int:
        """Converts decimal odds to American odds."""
        if pd.isna(decimal_odds) or decimal_odds == 0:
            return 0
        if decimal_odds >= 2.0:
            return round((decimal_odds - 1) * 100)
        else:
            return round(-100 / (decimal_odds - 1))

    def _load_rl_agent(self):
        """Loads the trained PPO reinforcement learning agent."""
        self.rl_agent = None
        if PPO is None:
            logger.warning("Cannot load RL agent because stable_baselines3 is not installed.")
            return

        rl_agent_zip_path = f"{self.rl_agent_path}.zip"
        if os.path.exists(rl_agent_zip_path):
            self.rl_agent = PPO.load(rl_agent_zip_path, device=self.device)
            logger.info(f"Successfully loaded RL betting agent from {rl_agent_zip_path}.")
        else:
            logger.warning(f"RL agent not found at {rl_agent_zip_path}. Betting decisions will be rule-based.")

    # In RealtimePredictionOrchestrator class, add these new functions
    # In RealtimePredictionOrchestrator class
    def run_daily_bets(self, target_date: str):
        """
        Streamlined process to generate and display bets for a single day.
        """
        logger.info(f"----- STARTING DAILY BETTING PIPELINE FOR {target_date} -----")

        # 1. Generate today's base features
        raw_features_df = self.feature_pipeline.process_todays_games(target_date)
        if raw_features_df.empty:
            logger.info("No games scheduled for today. Exiting.")
            return

        # --- START FIX ---
        # Explicitly run the AdvancedFeatureEngineer to create all necessary columns.
        # This ensures columns like 'park_factor' and 'weather_score_impact' exist before prediction.
        logger.info("Creating advanced features for today's games...")
        advanced_features_df = self.model.feature_pipeline.advanced_engineer.create_advanced_features(raw_features_df.copy())
        # --- END FIX ---

        # 2. Fetch live odds
        live_odds = self._fetch_live_odds(raw_features_df, target_date)
        
        # 3. Merge odds into the ADVANCED features DataFrame
        games_data_combined = self._merge_features_with_odds(advanced_features_df, live_odds)
        if games_data_combined.empty:
            logger.warning("No games with matched odds found. Cannot generate bets.")
            return

        # 4. Analyze bets using the authoritative V3 Analyzer
        logger.info("Analyzing today's games using the CalibratedBettingAnalyzer...")
        ml_bets = self.model.analyzer.analyze_moneyline(games_data_combined, live_odds)
        total_bets = self.model.analyzer.analyze_totals(games_data_combined, live_odds)
        all_analyzed_bets = ml_bets + total_bets
        logger.info(f"Analyzer identified {len(all_analyzed_bets)} potential opportunities.")

        # 5. Convert bets to the format the RL agent expects
        opportunities = self._convert_bets_to_opportunities(all_analyzed_bets, target_date)

        # 6. Get final decisions from the RL Agent
        agent_decisions = self._get_rl_agent_decisions(opportunities, target_date)
        
        # 7. Display the final results
        self.display_results(agent_decisions, raw_features_df, live_odds)

    def _convert_bets_to_opportunities(self, analyzed_bets: List[EnhancedBet], target_date: str) -> List[BettingOpportunity]:
        """Converts the V3 EnhancedBet objects to V5 BettingOpportunity objects."""
        opportunities = []
        for bet in analyzed_bets:
            opportunities.append(
                BettingOpportunity(
                    game_id=bet.game_id,
                    date=target_date,
                    bet_type=bet.bet_type,
                    selection=bet.selection,
                    probability=bet.probability,
                    edge=bet.edge,
                    confidence=bet.confidence,
                    uncertainty=bet.uncertainty,
                    kelly_stake=bet.kelly_stake,
                    odds=bet.odds,
                    home_team=bet.model_prediction.get('home_team', ''),
                    away_team=bet.model_prediction.get('away_team', '')
                )
            )
        return opportunities

    # In RealtimePredictionOrchestrator class
    def _get_rl_agent_decisions(self, opportunities: List[BettingOpportunity], target_date: str) -> Dict:
        """Runs the RL agent on a list of opportunities to get final decisions."""
        agent_decisions = defaultdict(list)
        if not self.rl_agent or not opportunities:
            return agent_decisions

        logger.info("Getting final betting decisions from RL Agent...")
        rl_env = MLBBettingEnvironmentV4(daily_opportunities={target_date: opportunities})
        obs, _ = rl_env.reset()
        done = False
        
        while not done:
            # --- FIX: This is the correct sequence ---
            # 1. Get the agent's action based on the current observation
            action, _ = self.rl_agent.predict(obs, deterministic=True)
            # 2. Pass the action to the environment and unpack all 5 return values, including 'info'
            obs, _, done, _, info = rl_env.step(action)
            # --- END FIX ---
            
            if info.get('action_type') == 1:
                bet_info = info.get('bet', {})
                game_id = bet_info.get('game_id')
                if game_id:
                    agent_decisions[game_id].append({
                        "action": "BET",
                        "selection": bet_info.get('selection'),
                        "bet_type": bet_info.get('bet_type'),
                        "stake_pct": bet_info.get('kelly_stake', 0) * 0.5 * info.get('size_multiplier', 0)
                    })
        return agent_decisions

    def display_results(self, agent_decisions: Dict, raw_features_df: pd.DataFrame, live_odds: Dict):
        """Formats and prints the final betting recommendations."""
        output_data = []
        # This ensures that 'game_pk' is a string for matching keys in live_odds if they are strings
        raw_features_df['game_pk_str'] = raw_features_df['game_pk'].astype(str)
        
        for _, game in raw_features_df.iterrows():
            # Match on string version of game_pk
            decisions_for_game = agent_decisions.get(game['game_pk_str'])
            
            if not decisions_for_game:
                continue

            for decision in decisions_for_game:
                selection_display = ""
                if decision['bet_type'] == 'total':
                    # Match on integer version of game_pk for live_odds
                    total_line = live_odds.get(game['game_pk'], {}).get('total', '')
                    selection_display = f"{decision['selection'].upper()} {total_line}"
                else:
                    selection_display = f"{decision['selection'].upper()} ML"

                output_data.append({
                    "Matchup": f"{game['away_team']} @ {game['home_team']}",
                    "Selection": selection_display,
                    "Stake %": f"{decision['stake_pct'] * 100:.2f}%"
                })

        if not output_data:
            logger.info("The RL agent recommended no bets for today.")
            return
            
        final_df = pd.DataFrame(output_data)
        
        print("\n" + "="*80)
        print(f"FINAL BETTING RECOMMENDATIONS FOR {datetime.now().strftime('%Y-%m-%d')}")
        print("="*80)
        print(final_df.to_string(index=False))
        
    def _merge_features_with_odds(self, raw_features_df: pd.DataFrame, live_odds: Dict) -> pd.DataFrame:
        """Merges live odds into the feature DataFrame to create the final input for the analyzer."""
        odds_list = []
        for game_pk, odds in live_odds.items():
            odds_list.append({
                'game_pk': game_pk,
                'home_ml': self._american_to_decimal(odds.get('home_ml')),
                'away_ml': self._american_to_decimal(odds.get('away_ml')),
                'total_line': odds.get('total'),
                'over_odds': self._american_to_decimal(odds.get('over_odds')),
                'under_odds': self._american_to_decimal(odds.get('under_odds')),
            })
        if not odds_list:
            return pd.DataFrame()
        
        odds_df = pd.DataFrame(odds_list)
        
        raw_features_df['game_id'] = raw_features_df['game_pk'].astype(str)
        odds_df['game_id'] = odds_df['game_pk'].astype(str)
        
        combined_df = pd.merge(raw_features_df, odds_df, on="game_id", how="inner")
        return combined_df

    def _decimal_to_american(self, decimal_odds: float) -> int:
        """Converts decimal odds to American odds."""
        if pd.isna(decimal_odds):
            return 0
        if decimal_odds >= 2.0:
            return round((decimal_odds - 1) * 100)
        else:
            return round(-100 / (decimal_odds - 1))

    def _american_to_decimal(self, american_odds: int) -> float:
        """Converts American odds to decimal odds."""
        if american_odds >= 100:
            return (american_odds / 100) + 1
        elif american_odds < 100:
            return (100 / abs(american_odds)) + 1
        return 1
    
    def _fetch_live_odds(self, games_df: pd.DataFrame, target_date: str) -> Dict[int, Dict]:
        """
        Fetches, matches, and pivots odds using the robust logic from addColumnsv2.py.
        """
        if self.db_connection is None or not hasattr(self, 'full_name_to_abbrev'):
            logger.error("No database connection or team mappings. Cannot fetch odds.")
            return {}

        logger.info(f"Fetching live market odds for {target_date} from SQL...")

        # Define the date range for the query (the entire target day in UTC)
        start_utc = pd.to_datetime(target_date).tz_localize('US/Eastern').tz_convert('UTC')
        end_utc = start_utc + pd.Timedelta(days=1)

        query = f"""
        WITH LatestOdds AS (
            SELECT *,
                   ROW_NUMBER() OVER(PARTITION BY game_id, market, outcome, point ORDER BY snapshot_time DESC) as rn
            FROM mlb_odds_history
            WHERE commence_time >= '{start_utc.strftime('%Y-%m-%d %H:%M:%S')}'
              AND commence_time < '{end_utc.strftime('%Y-%m-%d %H:%M:%S')}'
              AND market IN ('h2h', 'totals')
        )
        SELECT game_id, home_team, away_team, market, outcome, odds, point
        FROM LatestOdds
        WHERE rn = 1
        """

        try:
            odds_df = pd.read_sql(query, self.db_connection.engine)
            if odds_df.empty:
                logger.warning("No odds found in the database for today's games.")
                return {}
        except Exception as e:
            logger.error(f"Failed to execute odds query: {e}")
            return {}

        # 1. Normalize team names in odds data
        odds_df['home_team_norm'] = odds_df['home_team'].apply(self._normalize_team_name)
        odds_df['away_team_norm'] = odds_df['away_team'].apply(self._normalize_team_name)
        odds_df['game_date'] = pd.to_datetime(target_date)

        # 2. Create match keys and merge
        def create_match_key(row, home_col, away_col):
            # --- FIX: Convert game_date string to datetime object before formatting ---
            game_date_obj = pd.to_datetime(row['game_date'])
            return f"{row[home_col]}_{row[away_col]}_{game_date_obj.strftime('%Y-%m-%d')}"
        
        odds_df['match_key'] = odds_df.apply(lambda r: create_match_key(r, 'home_team_norm', 'away_team_norm'), axis=1)
        games_df['match_key'] = games_df.apply(lambda r: create_match_key(r, 'home_team_abbr', 'away_team_abbr'), axis=1)

        matched_df = odds_df.merge(games_df, on='match_key', how='inner')

        if matched_df.empty:
            logger.warning("Could not match any fetched odds to today's game schedule.")
            return {}

        # 3. Pivot the matched odds data
        live_odds = {}
        for game_pk, game_group in matched_df.groupby('game_pk'):
            # Process Moneyline (h2h)
            ml_df = game_group[game_group['market'] == 'h2h']
            home_team_name = game_group['home_team_x'].iloc[0] # From odds_df
            away_team_name = game_group['away_team_x'].iloc[0] # From odds_df
            
            home_odds_dec = ml_df[ml_df['outcome'] == home_team_name]['odds'].values
            away_odds_dec = ml_df[ml_df['outcome'] == away_team_name]['odds'].values
            
            # Process Totals
            totals_df = game_group[game_group['market'] == 'totals']
            total_line, over_odds_dec, under_odds_dec = 0, None, None
            if not totals_df.empty:
                total_line = totals_df['point'].mode().iloc[0]
                line_df = totals_df[totals_df['point'] == total_line]
                over_odds_dec = line_df[line_df['outcome'] == 'Over']['odds'].values
                under_odds_dec = line_df[line_df['outcome'] == 'Under']['odds'].values

            # 4. Convert to American and store
            live_odds[game_pk] = {
                'home_ml': self._decimal_to_american(home_odds_dec[0] if len(home_odds_dec) > 0 else 0),
                'away_ml': self._decimal_to_american(away_odds_dec[0] if len(away_odds_dec) > 0 else 0),
                'total': total_line,
                'over_odds': self._decimal_to_american(over_odds_dec[0] if over_odds_dec is not None and len(over_odds_dec) > 0 else 0) or -110,
                'under_odds': self._decimal_to_american(under_odds_dec[0] if under_odds_dec is not None and len(under_odds_dec) > 0 else 0) or -110
            }

        logger.info(f"Successfully processed odds for {len(live_odds)} games.")
        return live_odds

# In mlb_realtimeBet.py, inside the RealtimePredictionOrchestrator class

    def _save_predictions_for_dashboard(self, df_to_save: pd.DataFrame):
        """Saves the final predictions DataFrame to a JSON file."""
        output_path = r"C:\Users\DMelv\Documents\bettingModelBaseball\apiBaseball\pipeline\artemis\json\daily_predictions_TOM.json"
        logger.info(f"Saving predictions for dashboard to {output_path}...")
        
        # Add a timestamp to know when the file was last updated
        output_data = {
            'last_updated': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'predictions': df_to_save.to_dict(orient='records')
        }
        
        with open(output_path, 'w') as f:
            json.dump(output_data, f, indent=2)
        logger.info("✅ Predictions saved successfully.")

    # In mlb_realtimeBet.py, replace the existing run_daily_pipeline function

    def run_daily_pipeline(self, target_date: str = None):
        if target_date is None:
            target_date = datetime.now().strftime('%Y-%m-%d')
        
        logger.info(f"----- STARTING PIPELINE RUN FOR {target_date} -----")

        # 1. Generate Features (No changes here)
        raw_features_df = self.feature_pipeline.process_todays_games(target_date)
        if raw_features_df.empty:
            logger.info("No games scheduled for today. Exiting.")
            return pd.DataFrame()
        
        team_id_to_abbrev = self.team_id_to_abbrev
        raw_features_df['home_team_abbr'] = raw_features_df['home_team_id'].map(team_id_to_abbrev)
        raw_features_df['away_team_abbr'] = raw_features_df['away_team_id'].map(team_id_to_abbrev)
        raw_features_df['Matchup'] = raw_features_df['away_team'] + ' @ ' + raw_features_df['home_team']

        # 2. Preprocess & Predict (No changes here)
        adv_features_df = self.feature_engineer.create_advanced_features(raw_features_df.copy())
        for col in self.feature_selector.selected_features:
            if col not in adv_features_df.columns:
                adv_features_df[col] = 0.0
        selected_features_df = self.feature_selector.transform(adv_features_df)
        scaled_features = self.scaler.transform(selected_features_df)
        final_predictions = self.stacking_ensemble.predict(pd.DataFrame(scaled_features, columns=selected_features_df.columns))
        
        raw_features_df['predicted_home_score'] = final_predictions[:, 0]
        raw_features_df['predicted_away_score'] = final_predictions[:, 1]
        raw_features_df['home_win_prob'] = 1 / (1 + np.exp(-(final_predictions[:, 0] - final_predictions[:, 1]) * 0.7))
        
        # 3. Fetch live odds (No changes here)
        live_odds = self._fetch_live_odds(raw_features_df, target_date)
        def to_prob(o):
            if o == 0: return 0.5
            return -o / (-o + 100) if o < 0 else 100 / (o + 100)

        # 4. Create ALL opportunities (No changes here)
        opportunities = []
        for _, game in raw_features_df.iterrows():
            game_pk = game['game_pk']
            if game_pk not in live_odds or not live_odds[game_pk]['home_ml']:
                continue
            
            odds = live_odds[game_pk]
            
            # --- MONEYLINE OPPORTUNITIES ---
            home_prob = game['home_win_prob']
            home_prob_market = to_prob(odds['home_ml']) / (to_prob(odds['home_ml']) + to_prob(odds['away_ml']))
            home_edge = home_prob - home_prob_market
            home_dec_odds = self._american_to_decimal(odds['home_ml'])
            away_dec_odds = self._american_to_decimal(odds['away_ml'])
            home_kelly = (home_edge / (home_dec_odds - 1)) if home_dec_odds > 1 and home_edge > 0 else 0
            away_kelly = ((-home_edge) / (away_dec_odds - 1)) if away_dec_odds > 1 and -home_edge > 0 else 0
            
            opportunities.append(BettingOpportunity(
                game_id=str(game_pk), date=target_date, bet_type='moneyline',
                selection='home', probability=home_prob, edge=home_edge,
                confidence=abs(home_prob-0.5)*2, uncertainty=1-(abs(home_prob-0.5)*2),
                kelly_stake=home_kelly, odds=odds['home_ml'], 
                home_team=game['home_team'], away_team=game['away_team']
            ))
            
            opportunities.append(BettingOpportunity(
                game_id=str(game_pk), date=target_date, bet_type='moneyline',
                selection='away', probability=1-home_prob, edge=-home_edge,
                confidence=abs((1-home_prob)-0.5)*2, uncertainty=1-(abs((1-home_prob)-0.5)*2),
                kelly_stake=away_kelly, odds=odds['away_ml'], 
                home_team=game['home_team'], away_team=game['away_team']
            ))
            
            # --- TOTALS OPPORTUNITIES ---
            if 'total' in odds and odds['total'] > 0:
                predicted_total = game['predicted_home_score'] + game['predicted_away_score']
                market_total = odds['total']
                over_prob = 1 - torch.distributions.Normal(predicted_total, 3.0).cdf(torch.tensor(market_total)).item()
                over_prob_market = to_prob(odds['over_odds']) / (to_prob(odds['over_odds']) + to_prob(odds['under_odds']))
                over_edge = over_prob - over_prob_market
                under_edge = -over_edge
                over_dec_odds = self._american_to_decimal(odds['over_odds'])
                under_dec_odds = self._american_to_decimal(odds['under_odds'])
                over_kelly = (over_edge / (over_dec_odds - 1)) if over_dec_odds > 1 and over_edge > 0 else 0
                under_kelly = (under_edge / (under_dec_odds - 1)) if under_dec_odds > 1 and under_edge > 0 else 0
                
                opportunities.append(BettingOpportunity(
                    game_id=str(game_pk), date=target_date, bet_type='total', selection='over',
                    probability=over_prob, edge=over_edge, kelly_stake=over_kelly, odds=odds['over_odds'],
                    home_team=game['home_team'], away_team=game['away_team'], 
                    confidence=abs(over_prob-0.5)*2, uncertainty=1-(abs(over_prob-0.5)*2)
                ))
                
                opportunities.append(BettingOpportunity(
                    game_id=str(game_pk), date=target_date, bet_type='total', selection='under',
                    probability=1 - over_prob, edge=under_edge, kelly_stake=under_kelly, odds=odds['under_odds'],
                    home_team=game['home_team'], away_team=game['away_team'], 
                    confidence=abs((1-over_prob)-0.5)*2, uncertainty=1-(abs((1-over_prob)-0.5)*2)
                ))


        # --- FIX 1 of 2: Change how agent decisions are stored ---
        agent_decisions = defaultdict(list) # Use a defaultdict to handle lists of bets
        
        if self.rl_agent and opportunities:
            logger.info(f"Getting betting decisions from RL Agent... Found {len(opportunities)} opportunities")
            
            rl_env = MLBBettingEnvironmentV4(daily_opportunities={target_date: opportunities})
            obs, _ = rl_env.reset()
            done = False
            
            while not done:
                action, _ = self.rl_agent.predict(obs, deterministic=True)
                obs, _, done, _, info = rl_env.step(action)
                bet_info = info.get('bet', {})
                game_id = bet_info.get('game_id')
                
                if not game_id: 
                    continue
                
                # The agent chooses action 1 to place a bet
                if info.get('action_type') == 1:  # Bet
                    # Append the decision instead of overwriting it
                    agent_decisions[game_id].append({
                        "action": "BET", 
                        "selection": bet_info.get('selection'),
                        "bet_type": bet_info.get('bet_type'),
                        "size_multiplier": info.get('size_multiplier'),
                        "kelly_stake": bet_info.get('kelly_stake', 0)
                    })
                    logger.info(f"Agent decision: BET on {bet_info.get('bet_type')} - {bet_info.get('selection')} for game {game_id}")
        else:
            logger.info("RL Agent not available or no opportunities found.")

        # --- FIX 2 of 2: Change how the final output is formatted ---
        output_data = []
        for _, game in raw_features_df.iterrows():
            game_pk_str = str(game['game_pk'])
            decisions_for_game = agent_decisions.get(game_pk_str)

            if not decisions_for_game:
                # If there are no bets for this game, it's a PASS
                output_data.append({
                    "Matchup": f"{game['away_team']} @ {game['home_team']}",
                    "Pred Score": f"{game['predicted_away_score']:.2f} - {game['predicted_home_score']:.2f}",
                    "Home Win Prob": game['home_win_prob'] * 100,
                    "Agent Action": "PASS",
                    "Selection": "-",
                    "Stake %": 0
                })
            else:
                # If there are bets, create a separate row for EACH one
                for decision in decisions_for_game:
                    stake_pct = 0
                    if decision['action'] == 'BET':
                        half_kelly_stake = decision.get('kelly_stake', 0) * 0.5 
                        stake_pct = half_kelly_stake * decision.get('size_multiplier', 0)

                    selection_display = '-'
                    if decision.get('selection'):
                        if decision.get('bet_type') == 'total':
                            # Display Over/Under with the line
                            total_line = live_odds[game['game_pk']].get('total', '')
                            selection_display = f"{decision['selection'].upper()} {total_line}"
                        else: # moneyline
                            selection_display = f"{decision['selection'].upper()} ML"

                    output_data.append({
                        "Matchup": f"{game['away_team']} @ {game['home_team']}",
                        "Pred Score": f"{game['predicted_away_score']:.2f} - {game['predicted_home_score']:.2f}",
                        "Home Win Prob": game['home_win_prob'] * 100,
                        "Agent Action": decision['action'],
                        "Selection": selection_display,
                        "Stake %": stake_pct * 100
                    })

        output_df = pd.DataFrame(output_data)
        return output_df

# In mlb_realtimeBet.py, replace the main block at the bottom

if __name__ == "__main__":
    orchestrator = RealtimePredictionOrchestrator(
        rl_agent_path=RL_AGENT_PATH
    )

    # --- FIX: Get today's date dynamically ---
    # The script logic uses US/Eastern as the reference timezone for a 'day'.
    eastern_tz = pytz.timezone('US/Pacific')
    todays_date_str = datetime.now(eastern_tz).strftime('%Y-%m-%d')
    logger.info(f"Dynamically setting target_date to: {todays_date_str}")

    orchestrator.run_daily_bets(
        target_date=todays_date_str # Use the dynamic date variable here
    )
    
    logger.info("----- PIPELINE COMPLETED -----")